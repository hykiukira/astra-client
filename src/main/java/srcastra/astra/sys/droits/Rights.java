/* * Rights.java * * Created on 24 juillet 2002, 14:06 */package srcastra.astra.sys.droits;import java.util.*;import java.io.*;import srcastra.astra.sys.Logger;/** * This module implement right checking for actions. * All actions are described in an individual string. * The list of string is inited by the first call to a constructor * or by any static function returning a right object  * (implicit constructor call) * * * Here is the list of string rights: * <ul> * <li> read client entity * <li> create client entity * <li> modify client entity * <li> delete client entity * <li> grant client entity * <li> read fournisseur entity * <li> create fournisseur entity * <li> modify fournisseur entity * <li> delete fournisseur entity * <li> grant fournisseur entity * <li> read signaletique entity * <li> create signaletique entity * <li> modify signaletique entity * <li> delete signaletique entity * <li> grant signaletique entity * <li> read client foreign * <li> create client foreign * <li> modify client foreign * <li> delete client foreign * <li> grant client foreign * <li> read fournisseur foreign * <li> create fournisseur foreign * <li> modify fournisseur foreign * <li> delete fournisseur foreign * <li> grant fournisseur foreign * <li> read signaletique foreign * <li> create signaletique foreign * <li> modify signaletique foreign * <li> delete signaletique foreign * <li> grant signaletique foreign * <li> read client groupement * <li> create client groupement * <li> modify client groupement * <li> delete client groupement * <li> grant client groupement * <li> read fournisseur groupement * <li> create fournisseur groupement * <li> modify fournisseur groupement * <li> delete fournisseur groupement * <li> grant fournisseur groupement * <li> read signaletique groupement * <li> create signaletique groupement * <li> modify signaletique groupement * <li> delete signaletique groupement * <li> grant signaletique groupement * </ul> * @author  david */public class Rights extends java.lang.Object implements java.io.Externalizable{    public final static int __RIGHT_READ         = 0;    public final static int __RIGHT_CREATE       = 1;    public final static int __RIGHT_MODIFY       = 1;    public final static int __RIGHT_DELETE       = 2;    public final static int __RIGHT_GRANT        = 3;    public final static int __MAX_RIGHT_BASE     = __RIGHT_GRANT;                private final static int __BASE_RIGHT_MUL     = __MAX_RIGHT_BASE+1;    public final static int __RIGHT_CLIENT       = 0*__BASE_RIGHT_MUL;    public final static int __RIGHT_FOURNISSEUR  = 1*__BASE_RIGHT_MUL;    public final static int __RIGHT_SIGNALETIQUE = 2*__BASE_RIGHT_MUL;    public final static int __MAX_RIGHT_MIDDLE   = __RIGHT_SIGNALETIQUE;        private final static int __MIDDLE_RIGHT_MUL   = __MAX_RIGHT_MIDDLE+__BASE_RIGHT_MUL;    public final static int __RIGHT_ENTITY       = 0*__MIDDLE_RIGHT_MUL;    public final static int __RIGHT_FOREIGN      = 1*__MIDDLE_RIGHT_MUL;    public final static int __RIGHT_GROUPEMENT   = 2*__MIDDLE_RIGHT_MUL;     public final static int __MAX_RIGHT_HIGH     = __RIGHT_GROUPEMENT;        public static int MAX_SERVER_RIGHT = __MAX_RIGHT_BASE+__MAX_RIGHT_MIDDLE+__MAX_RIGHT_HIGH;          public static int MAX_RIGHT = MAX_SERVER_RIGHT;                private static Boolean isinited = new Boolean (false);    private static Hashtable rights = new Hashtable (MAX_SERVER_RIGHT);        private static String hexa= "0123456789ABCDEF";    private byte[] rightField = null;        public static String[] base_name = new String[] {"read","create","modify","delete","grant"};    public static String[] middle_name = new String [] {"client","fournisseur","signaletique"};    public static String[] high_name = new String[] {"entity","foreign","groupement"};    /*-- Static methods --*/    private static void initFields ()    {        int[] base_value= new int[] {__RIGHT_READ,__RIGHT_CREATE,__RIGHT_MODIFY,__RIGHT_DELETE,__RIGHT_GRANT};        int[] middle_value = new int[] {__RIGHT_CLIENT,__RIGHT_FOURNISSEUR,__RIGHT_SIGNALETIQUE};        int[] high_value = new int[] {__RIGHT_ENTITY,__RIGHT_FOREIGN,__RIGHT_GROUPEMENT};        for (int high=0;high<3;high++)            for (int middle=0;middle<3;middle++)                for (int base=0;base<5;base++)                {                    String tmp = base_name[base]+" "                            +middle_name[middle]+" "                            +high_name[high];                    int value= base_value[base]+                            +middle_value[middle]+                            +high_value[high];                    rights.put(tmp,new Integer (value));                    Logger.getDefaultLogger().log(Logger.LOG_DEBUG,tmp+"=    "+value);                }    }    public static Rights getDefaultRights ()    {        try        {            return new Rights("0101");        }        catch (java.text.ParseException e)        {            return new Rights();        }    }        /*-- Constructors --*/        /** Creates a new instance of Rights.      * By default, no right applies!      */    public Rights() {        synchronized (isinited)        {            if (!isinited.booleanValue())            {                initFields();                isinited = new Boolean (true);            }        }        rightField = new byte[MAX_SERVER_RIGHT/8+1];        for (int i=0; i<rightField.length; i++)            rightField[i]=0;            }    /** Creates a new instance of rights.      * Uses the rights specified in the parameter strung.     * Format of the string is the same as the one given by toString()     */    public Rights (String value) throws java.text.ParseException{        this();        this.fromString(value);    }        /*-- Private functions --*/    private String toHexa (byte value)    {        Logger.getDefaultLogger().log(Logger.LOG_DEBUG,"Converting "+value+": "+((value>>4)&15)+"-"+(value&15));        return ""+hexa.charAt((value>>4)&15)+hexa.charAt(value&15);    }    private byte fromHexa (String chars) throws java.text.ParseException    {        int a = hexa.indexOf(chars.charAt(0));        int b = hexa.indexOf(chars.charAt(1));        if (a<0)            throw new java.text.ParseException("Error parsing "+hexa.indexOf(chars.charAt(0)),0);        else if (b<0)            throw new java.text.ParseException("Error parsing "+hexa.indexOf(chars.charAt(1)),0);        return (byte)(a*16+b);            }    private void toggleBit (int bitNumber)    {        rightField[bitNumber/8]=(byte)(rightField[bitNumber/8]^(1 <<(bitNumber%8)));    }    private void clearBit (int bitNumber)    {        rightField[bitNumber/8]=(byte)(rightField[bitNumber/8]&(~(1 <<(bitNumber%8))));    }    private void rightExtend (int byteQty)    {        if (byteQty >= rightField.length)            return;        byte[] tmp = new byte[byteQty];        System.arraycopy(rightField,0,tmp,0,rightField.length);        for (int i = rightField.length; i<byteQty;i++)            tmp[i]=0;        rightField= tmp;    }        private void setRight (int bit, Rights administrator) throws SecurityException    {        if (bit<0)             throw new SecurityException ("The permission number"+bit+" is a negative value");        else        {            Logger.getDefaultLogger().log(Logger.LOG_DEBUG,"Trying to grant "+bit);            int admbit =(bit /__BASE_RIGHT_MUL)*__BASE_RIGHT_MUL;            admbit +=__RIGHT_GRANT;            Logger.getDefaultLogger().log(Logger.LOG_DEBUG,"Comparing with "+admbit);            if (administrator.getBit(admbit))                setBit (bit);            else                throw new SecurityException ("You do not have the permission to grant this access to someone");        }                    }    private void setBit (int bitNumber)    {        if (bitNumber<0)            return;        if ((bitNumber/8)>=rightField.length)            rightExtend (bitNumber/8+1);        rightField[bitNumber/8]=(byte)(rightField[bitNumber/8]|(1 <<(bitNumber%8)));    }        /*-- Public functions --*/        /** Chekcs if the right allow this operation. **/    public boolean allowed (String name)    {        return getBit (name);    }    /** Allow a user to do specific action.     * Administrator must have associated grant rights.      */    public void grantRight (String name, Rights administrator) throws SecurityException    {        int bit = getBitNumber (name);        if (bit<0)             throw new SecurityException ("The permission "+name+" does not exist.");        setRight (bit,administrator);            }    /** Get the bit number for a specific right.     */    public int getBitNumber (String name)    {        Integer value=(Integer)rights.get(name);        return value==null?-1:value.intValue();    }    /** Get the status of the right bit associated with the name d right */    public boolean getBit (String name)    {                return getBit(getBitNumber(name));    }    /** Get the status of the right represented by the specified bit */    public boolean getBit (int bitNumber)    {        if (bitNumber<0)            return false;        try        {            return (rightField[bitNumber/8]&(1 <<(bitNumber%8)))!=0;        }        catch (ArrayIndexOutOfBoundsException e)        {        return false;        }    }        /** Creates a string representing the rights a user have */    public String toString()    {        String tmp="";        for (int i=rightField.length-1;i>=0;i--)            /*for (int j=7;j>=0;j--)                tmp+=getBit(j+i*8)?"X":"0";*/            tmp+=toHexa(rightField[i]);        return tmp;    }    /** read the rights form a text string.     * See toString()     */    public void fromString(String values) throws java.text.ParseException    {        Logger.getDefaultLogger().log(Logger.LOG_DEBUG,"Parsing rights: -->"+values+"<--");        int size= values.length()/2+(values.length()%2==0?0:1);                byte[] tmpright= new byte[size];                char[] tmpchar= values.toCharArray();        String tmpstring=null;        for (int i=0;i<tmpchar.length;i+=2)        {            /*char bit= tmpchar[tmpchar.length-i-1];            //System.out.println ("Reading "+bit);            if (bit=='X')                tmpright[i/8]|=1<<(i%8);            else if (bit!='0')                throw new java.text.ParseException (values,tmpchar.length-i-1);*/            tmpstring=values.substring(i,i+2);            tmpright[i/2]=fromHexa(tmpstring);        }        rightField=tmpright;    }        public void dump()    {        for (int i = 0; i<this.rightField.length;i++)        {            Logger.getDefaultLogger().log(Logger.LOG_DEBUG,"Byte "+i+": ");            for (int j=7;j>=0;j--)            {                if (this.getBit(j+i*8))                    Logger.getDefaultLogger().log(Logger.LOG_DEBUG,"1");                else                     Logger.getDefaultLogger().log(Logger.LOG_DEBUG,"0");            }        }    }    /**     * @param args the command line arguments         public static void main(String[] args) throws Exception {        Rights test = new Rights();        System.out.println ("bit 5: "+test.getBit(5));        test.setBit (5);        System.out.println ("bit 5: "+test.getBit(5));        test.dump();        test.clearBit (5);        System.out.println ("bit 5: "+test.getBit(5));        test.dump();        test.setBit (4);        test.setBit (3);        test.setBit (2);        test.setBit (6);        test.setBit (12);        test.setBit (20);        test.setBit (21);        test.setBit (22);        test.dump();        String tmp = test.toString();        System.out.println (tmp);        Rights test2 = new Rights();        test2.fromString("FFFFFFFFFF");        System.out.println (test2.toString());        test.grantRight("delete client groupement",test2);        test.grantRight("create signaletique groupement",test2);        test.grantRight("modify fournisseur entity",test2);        System.out.println(Rights.getDefaultRights().toString());        System.out.println (test.toString());        ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream("test"));        out.writeObject(test);        out.close();        ObjectInputStream in = new ObjectInputStream (new FileInputStream("test"));        test = (Rights)in.readObject();        in.close();        System.out.println (test.toString());            }*/        public void readExternal(java.io.ObjectInput objectInput) throws java.io.IOException, java.lang.ClassNotFoundException {        rightField = new byte[objectInput.readInt()];        objectInput.readFully(rightField);    }        public void writeExternal(java.io.ObjectOutput objectOutput) throws java.io.IOException {        objectOutput.writeInt (rightField.length);        objectOutput.write(rightField);    }    }