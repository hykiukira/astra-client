/* * Decision.java * * Created on 16 januari 2003, 16:03 */package srcastra.astra.sys.configuration;import srcastra.astra.sys.rmi.utils.Poolconnection;import java.sql.*;import java.util.Hashtable;import srcastra.astra.gui.modules.aidedesicion.*;import srcastra.astra.sys.classetransfert.dossier.produit_T;import srcastra.astra.sys.*;import java.util.*;/** * * @author  Thomas */public class Decision extends AbstractDecision{        /** Creates a new instance of Decision */AbstractRequete requete;int type;    public Decision(AbstractRequete requete) {        this.requete=requete;        block=new Hashtable();        block.put(new Integer(produit_T.AS),new Object());        block.put(new Integer(produit_T.AV),new Object());        block.put(new Integer(produit_T.BA),new Object());        block.put(new Integer(produit_T.BRO),new Object());        block.put(new Integer(produit_T.HO),new Object());        block.put(new Integer(produit_T.TAX),new Object());        block.put(new Integer(produit_T.TR),new Object());        block.put(new Integer(produit_T.VO),new Object());                                      // pstmt=tmpool.getConuser().prepareStatement("INSERT INTO aidedecision (cate_prod ,lmcleunik,Traduction)   VALUES(?,?,?)");            }    public Decision(AbstractRequete requete,int type) {        this.requete=requete;        this.type=type;    }    public Object insert(Object obj, Poolconnection tmpool) throws java.sql.SQLException{        return null;          }    public Object delete(int id, Poolconnection tmpool,int type) throws java.sql.SQLException {           checkDectree(tmpool);           boolean candelete=true;            synchronized(dectree){               Transaction.begin(tmpool.getConuser());               if(requete.checkBeforeDelete()!=null)               {                   for(int i=0;i<requete.checkBeforeDelete().length;i++){                    pstmt=tmpool.getConuser().prepareStatement(requete.checkBeforeDelete()[i]);                    pstmt.setInt(1,id);                    ResultSet result=pstmt.executeQuery();                    result.last();                    int row=result.getRow();                    if(row!=0){                        candelete=false;                        return new Boolean(false);                    }                   }                                  }               pstmt=tmpool.getConuser().prepareStatement(requete.delete1());               pstmt.setInt(1,id);               pstmt.execute();               pstmt=tmpool.getConuser().prepareStatement(requete.delete2());               pstmt.setInt(1,id);               pstmt.execute();               dectree.removeChildren(new Integer(id).toString(),type);                Transaction.commit(tmpool.getConuser());               dectree.afficheMe();               return new Insert_T(id,dectree.getTimestamp());             }    }         /** Creates a new instance of Decision  */    public Object insert(Object obj, Poolconnection tmpool, java.util.ArrayList data, int id2, int my_type) throws java.sql.SQLException{        checkDectree(tmpool);        Transaction.begin(tmpool.getConuser());        pstmt=tmpool.getConuser().prepareStatement(requete.insert1());        if(type==AbstractRequete.SUP_RECUC){            Object[] first=(Object[])data.get(0);            int compte=Integer.parseInt(first[5].toString());            int sup=Integer.parseInt(first[6].toString());            int def=Integer.parseInt(first[7].toString());            int tva=Integer.parseInt(first[8].toString());            int comptabilise=Integer.parseInt(first[9].toString());            int inclus=Integer.parseInt(first[10].toString());            pstmt.setInt(1,my_type);            pstmt.setInt(2,compte);            pstmt.setInt(3,sup);            pstmt.setInt(4,def);            pstmt.setInt(5, tva);            pstmt.setInt(6,comptabilise);            pstmt.setInt(7, inclus);            pstmt.execute();        }        else{            pstmt.setInt(1,my_type);            pstmt.execute();                  }        pstmt=tmpool.getConuser().prepareStatement("select LAST_INSERT_ID();");        ResultSet result=pstmt.executeQuery();        result.first();        int id=result.getInt(1);        pstmt=tmpool.getConuser().prepareStatement(requete.insert2());        Object[] first=(Object[])obj;        for(int i=0;i<data.size();i++){            Object[] second=(Object[])data.get(i);            second[0]=new Integer(id);            pstmt.setInt(1,id);            pstmt.setInt(2,my_type);            pstmt.setInt(3,((Integer)second[2]).intValue());            pstmt.setString(4,second[3].toString());            pstmt.execute();                    }        synchronized(dectree){            dectree.setData(data,id,my_type);        }        Transaction.commit(tmpool.getConuser());        dectree.afficheMe();     return new Insert_T(id,dectree.getTimestamp());    }        public Object modify(Object obj, Poolconnection tmpool, ArrayList data) throws java.sql.SQLException{        checkDectree(tmpool);        Transaction.begin(tmpool.getConuser());                int my_type=0;        int id=0;        if(type==AbstractRequete.SUP_RECUC){            pstmt=tmpool.getConuser().prepareStatement(requete.modify2());            Object[] first=(Object[])data.get(0);            id=((Integer)first[0]).intValue();            int compte=Integer.parseInt(first[5].toString());            int sup=Integer.parseInt(first[6].toString());            int def=Integer.parseInt(first[7].toString());            int tva=Integer.parseInt(first[8].toString());            int comptabilise=Integer.parseInt(first[9].toString());            int inclus=Integer.parseInt(first[10].toString());            pstmt.setInt(1,compte);            pstmt.setInt(2,sup);            pstmt.setInt(3,def);            pstmt.setInt(4,tva);            pstmt.setInt(5,comptabilise);            pstmt.setInt(6,inclus);            pstmt.setInt(7,id);                   pstmt.execute();        }        pstmt=tmpool.getConuser().prepareStatement(requete.modify1());        for(int i=0;i<data.size();i++){            Object[] first=(Object[])data.get(i);            id=((Integer)first[0]).intValue();            int langue=((Integer)first[2]).intValue();            my_type=((Integer)first[1]).intValue();            pstmt.setString(1,first[3].toString());            pstmt.setInt(2,id);            pstmt.setInt(3,langue);            pstmt.execute();                    }        synchronized(dectree){            dectree.setData(data,id,my_type);        }        Transaction.commit(tmpool.getConuser());        dectree.afficheMe();        return new Insert_T(id,dectree.getTimestamp());    }    public Object select(Poolconnection tmpool,long timestamp) throws java.sql.SQLException{       checkDectree(tmpool);        if(dectree!=null){             synchronized(dectree){                 if(timestamp==dectree.getTimestamp()){                     System.out.println("ok same timestamp");                             dectree.afficheMe();                     return dectree;                 }                 else{                     System.out.println("dectree back");                  //   dectree.afficheMe();                     return dectree;                 }             }        }        else         {            System.out.println("tree == null");            return null;        }    }    private void renvArraylist(ResultSet result){        if(result!=null);    }    public void synchonizeUsers() {    }    public void initDecisionTree(Poolconnection tmpool, AbstractBuffer dectree) throws SQLException{             dectree.setNumbeOfElement(requete.getNumberOfElement()+1);         dectree.setLmcleunik(tmpool.getLmcleunik());         for(int i=1;i<requete.getNumberOfElement()+1;i++){            ArrayList array=null;            pstmt=tmpool.getConuser().prepareStatement(requete.init());            pstmt.setInt(1,i);            ResultSet result=pstmt.executeQuery();            result.beforeFirst();            int q=1;            while (result.next()){                if(array==null)                    array=new ArrayList();                Object[] tmp=null;                if(type==AbstractRequete.SUP_RECUC)                       tmp=new Object[11];                else                       tmp=new Object[5];             tmp[0]=result.getObject(1);             tmp[1]=result.getObject(2);             tmp[2]=result.getObject(3);             tmp[3]=result.getObject(4);               tmp[4]=new Integer(q);             if(type==AbstractRequete.SUP_RECUC){              tmp[5]=result.getObject(5);              tmp[6]=result.getObject(6);              tmp[7]=result.getObject(7);              tmp[8]=result.getObject(8);              tmp[9]=result.getObject(9);              tmp[10]=result.getObject(10);             }             q++;             //tmp[4]=result.getObject(5);               array.add(tmp);                         }             if(array!=null){            /*for(int k=0;k<array.size();k++)            {              Object[] test=(Object[])array.get(k);              System.out.println("array "+" "+test[0]+"  "+test[1]+" "+test[2]+" "+test[3]);            }*/            getTheArrays2(array,i);            }        }//         dectree.afficheMe();    }    private ArrayList getTheArrays(ArrayList main,int type_produit){        Object first=null;        ArrayList tmp=null;         //cette fonction permet des séparer les arraylist en  fonction des catégorie de produit        int j=main.size();           if(main!=null && main.size()>0){            for(int i=0;i<main.size();i++){                tmp=new ArrayList();                first=(((Object[])main.get(i))[0]);                tmp.add((Object[])main.get(i));                i++;                if(i<j){                    while(first.equals(((Object[])main.get(i))[0])){                        tmp.add((Object[])main.get(i));                         i++;                        if(i==j)                           break;                    }                }                dectree.setData(tmp,((Integer)first).intValue(),type_produit);                                 }            }                return null;        }    private ArrayList getTheArrays2(ArrayList main,int type_produit){        Object[] first=null;        Object[] second=null;        ArrayList tmp=null;        int x1;        int x2;        int j=main.size();           if(main!=null && main.size()>0){            for(int i=0;i<main.size();i++){                 tmp=new ArrayList();                 first=(Object[])main.get(i);                 x1=((Integer)first[0]).intValue();                 tmp.add(first);                do{                    second=null;                    i++;                    second=(Object[])main.get(i);                    x2=((Integer)second[0]).intValue();                    if(x1==x2)                        tmp.add(second);                    else{                         i=i-1;                        break;                       }                }while(x1==x2 && i!=j-1);                 dectree.setData(tmp,x1,type_produit);                       if(i==j-1)                     break;                                  }            }                return null;        }         private void checkDectree(Poolconnection tmpool) throws SQLException { synchronized(new Object()){ if(dectree==null){    dectree=new DecFatory().getBuffer();    initDecisionTree(tmpool,dectree);     } } }                                                               int numberOfElement;Poolconnection m_pool;  PreparedStatement pstmt;Hashtable block;AbstractBuffer dectree;}