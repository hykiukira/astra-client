/* * ServeurBuffer.java * * Created on 4 juillet 2002, 9:28 */package srcastra.astra.sys.rmi.utils;import java.lang.*;import java.util.*;import java.io.*;import srcastra.astra.sys.compress.*;import srcastra.astra.sys.Logger;/** Class to implement a hierarchy in buffering. * Buffered element are classed in "directory" and  * all elements in a directory get invalidated  * when the directory is invalidated or one directory * in the root in it's path has been invalidated. * * * All buffered elements are referenced by strings * * @author  David * @version 1.02 - Cops-per-field revision */public class HashServeurBuffer extends java.lang.Object implements Externalizable, ServeurBuffer{    private Hashtable subBuffers;    private Hashtable datas;    private String name;    private static long serialVersion = 666;        /** dummy object to replace a null in Hashtables */    public static transient Object dummyObject = new String("Dummy variable");    //private String dummyObject = new String();    /** set to true to be verbose */    public /*static final transient*/ boolean verbose = true;    /** set to true to crash on problems(not implemented yet) */    public /*static final transient*/ boolean fastcrash = false;    /** Creates a new directory with no sub directory and no element.     */    public HashServeurBuffer()    {        subBuffers=new Hashtable();        datas = new Hashtable();//        notifier = new BufferNotifier ();    }    /*    public BufferNotifier getNotifier()    {        return notifier;    }*//*    private void setNotifierFromParent (HashServeurBuffer parent)    {        notifier=parent.getNotifier();        Enumeration tmp = subBuffers.keys();        ServeurBuffer buf;        while (tmp.hasMoreElements())        {            buf=(ServeurBuffer)tmp.nextElement();            if (buf.getClass().getName() == this.getClass().getName())            {                ((HashServeurBuffer)buf).setNotifierFromParent(this);            }        }    }*/        /** Set the value "name" to the specified objects.     * First, this function searches for "name"      * in referenced subdirectories. If it can be found, setValue is      * called on this directory. Else, the value is inserted or updated     * in the current directory.      * This is the only way to create a value in the root entry.     */    public void setValue(String name, Object buf)    {                      ServeurBuffer sub=(ServeurBuffer)subBuffers.get(name);                if (sub!=null)        {            sub.setValue(name,buf);        }        else        {            if (buf==null)                buf=this.dummyObject;            System.out.println("[[[[[[[[BUFFER[]]]] j'ajoute"+name);            datas.put(name,buf);            if (this.verbose)            {                Logger.getDefaultLogger().log(Logger.LOG_DEBUG,"[Buffer]: setting "+name);                if (buf==this.dummyObject)                    Logger.getDefaultLogger().log(Logger.LOG_DEBUG," |---> set to dummy");            }        }    }    /** Searches for a specific value in the directory hierarchy.     * If the value cannot be found, the result is null     */    public CompressArray getValue(String name)    {        return (CompressArray)this.getObjectValue(name);    }    /** Searches for a specific value in the directory hierarchy.     * If the value cannot be found, the result is null.     * The value is returned as an object.     */    public Object getObjectValue(String name)    {        ServeurBuffer sub=(ServeurBuffer)subBuffers.get(name);        if (sub!=null)            return sub.getObjectValue(name);        else        {            Logger.getDefaultLogger().log(Logger.LOG_DEBUG,"[Buffer] Retrieving "+name);            if (datas.get(name)==this.dummyObject)                Logger.getDefaultLogger().log(Logger.LOG_DEBUG,"    |----> It's a dummy!");            return datas.get(name);        }    }    /** Invalidate the datas given by a name.     * If a path to the datas cannot be found, nothing is done.     */    public void invalidateBuffer(String bufferName)    {        ServeurBuffer buf= (ServeurBuffer)subBuffers.get(bufferName);        if (buf!=null)            buf.invalidate (bufferName);    }        /** invalidate the buffer datas and all datas in it's subdirectories.     */    public void invalidate ()    {        Logger.getDefaultLogger().log(Logger.LOG_DEBUG,"invalidating whole bunch");//        notifier.invalidate();        invalidate_private();    }    private void invalidate_private ()    {        Iterator buffers = subBuffers.entrySet().iterator();                HashServeurBuffer buf;        while (buffers.hasNext())        {            buf=(HashServeurBuffer)buffers.next();            buf.invalidate_private();        }        Enumeration keys = datas.keys();        Object tmp1;        Object tmp2;        while (keys.hasMoreElements())        {            tmp1=keys.nextElement();            tmp2=datas.get(tmp1);            System.out.println("j[[[[[[[[[[[]]]]]]]]]]]]]'invalide "+tmp1);            tmp2=null;            if (this.verbose)                Logger.getDefaultLogger().log(Logger.LOG_DEBUG,"[Buffer]Invalidating "+(String)tmp1);            datas.put (tmp1,this.dummyObject);        }    }    public void invalidate (String bufferName)    {        if (this.verbose)            Logger.getDefaultLogger().log(Logger.LOG_DEBUG,"[Buffer] Pathto "+bufferName);        ServeurBuffer buf= (ServeurBuffer)subBuffers.get(bufferName);        if (buf!=null)            buf.invalidate (bufferName);        else        {            this.invalidate_private();        }    }           /** Check if buffered represented by name has valid content     */    public boolean isValid (String name)    {        System.out.println("[[[[[[[[[BUFFER[]]]]]]]]]je checke pour"+name);        ServeurBuffer sub=(ServeurBuffer)subBuffers.get(name);        if (sub!=null)            return sub.isValid(name);        else        {            if (this.verbose)            {                Logger.getDefaultLogger().log(Logger.LOG_DEBUG,"[Buffer] isValid ("+name+"): ");                if (datas.get(name)==null){                    Logger.getDefaultLogger().log(Logger.LOG_DEBUG,"    |--> null");                     System.out.println("[[[[[[[[[BUFFER[]]]]]]]]]j NULL: "+name);                }                else if (datas.get(name)==this.dummyObject){                    Logger.getDefaultLogger().log(Logger.LOG_DEBUG,"    |--> dummy");                    System.out.println("[[[[[[[[[BUFFER[]]]]]]]]]j DUMMY: "+name);                }                else{                    Logger.getDefaultLogger().log(Logger.LOG_DEBUG,"    |--> Ok");                      System.out.println("[[[[[[[[[BUFFER[]]]]]]]]]j NOT NULL: "+name);                                                       }            }            return ((datas.get(name)!=null)                  &&(datas.get(name)!=this.dummyObject));        }    }    /** Add the specified hierarchy in an entrypoint     * named directoryName.     * User should take care that the imported hierarchy has      * no value name which could be already present in     * the current hierarchy.     */    public void importDirectory(String DirectoryName, ServeurBuffer buf)    {                String[] keys=buf.getKeys();        int i;        for (i=0;i<java.lang.reflect.Array.getLength(keys);i++)            subBuffers.put(keys[i],buf);            subBuffers.put(DirectoryName,buf);    }    /** link a new data buffer with the specified name.     * @param directoryName If this is the name of a directory,      * link the datas in this subdirectory, else link the datas in     * the subdirectory where directoryName relies.     * If directoryName does not exist, a warning is issued to the console     */    public void linkNewName (String name,String directoryName)    {        ServeurBuffer sub=(ServeurBuffer)subBuffers.get(directoryName);        if (sub==null)            Logger.getDefaultLogger().log(Logger.LOG_DEBUG,"linking "+name+" to "+directoryName+": tail end");        else        {            subBuffers.put(name,sub);            Logger.getDefaultLogger().log(Logger.LOG_DEBUG,"linking "+name+" to "+directoryName+": link follow up.");            sub.linkNewName(name,directoryName);        }    }    public String[] getKeys()    {        int size= subBuffers.size()+datas.size();        int i;        Enumeration tmp;        String[] result= new String[size];        tmp=subBuffers.keys();        for (i=0;i<subBuffers.size();i++)            result[i]=(String)tmp.nextElement();            tmp=datas.keys();        for (i=subBuffers.size();i<size;i++){            result[i]=(String)tmp.nextElement();        }        return result;    }    public String dumpString(String prefix)    {        String value = new String();        String tmpstring = "";        Hashtable hs = new Hashtable();        Enumeration keys= subBuffers.keys();        String str1;        String str2=null;        Object sub;        while (keys.hasMoreElements())        {            str1=(String)keys.nextElement();            sub=subBuffers.get(str1);            str2=(String)hs.get(sub);            if (str2==null)                str2=prefix+"[+] ";            str1=str2+"("+str1+") ";            hs.put(sub,str1);        }        keys=hs.keys();        while (keys.hasMoreElements())        {            sub=keys.nextElement();            str1=(String)hs.get(sub);            tmpstring = tmpstring+ str1 + "\n";            if ((keys.hasMoreElements()) || (datas.size()>0))                tmpstring = tmpstring + ((ServeurBuffer)(sub)).dumpString (prefix+" |    ");            else                tmpstring = tmpstring + ((ServeurBuffer)(sub)).dumpString (prefix+"      ");        }        keys=datas.keys();        while (keys.hasMoreElements())        {            str1=(String)keys.nextElement();            tmpstring = tmpstring + prefix+" |  "+str1+" -> ";            tmpstring = tmpstring + datas.get(str1).toString()+"\n";        }        tmpstring = tmpstring + prefix + "\n";        return tmpstring;    }    public String toString ()    {        String tmp = super.toString();        tmp="["+tmp+"]\nDatas:\n";        tmp=tmp+this.dumpString("");        return tmp;    }    public void dumpServeurBuffer ()    {        try        {            FileOutputStream sortie = new FileOutputStream ("d:\\Documents and Settings\\rene\\Mes documents\\astra\\streambuffer.raw");            ObjectOutputStream out = new ObjectOutputStream (sortie);            out.writeObject(this);            out.close();        }        catch (Exception e)        {            e.printStackTrace();            System.out.println ("-----------");            System.out.println(e.getMessage());            System.out.println ("-----------");            System.out.println(e.toString());        }    }        public ServeurBuffer getDirectory(String DirectoryName) {        return (ServeurBuffer) subBuffers.get(DirectoryName);    }        public long getTimestampValue(String name) {        Object tmp;        tmp=this.getObjectValue(name);        if ((tmp==null)||(tmp==this.dummyObject))            return System.currentTimeMillis();        else        {            Logger.getDefaultLogger().log(Logger.LOG_DEBUG,"tmp is "+tmp);            return ((Long)tmp).longValue();        }    }        public void readExternal(java.io.ObjectInput objectInput) throws java.io.IOException, java.lang.ClassNotFoundException {                      long l = objectInput.readLong();        if (l!=serialVersion)            throw new java.lang.ClassNotFoundException ("Serial of buffer mismatch");        Object tmp = objectInput.readObject();        name= objectInput.readUTF();        subBuffers = (Hashtable) objectInput.readObject();        datas = (Hashtable)      objectInput.readObject();        dummyObject = tmp;    }        public void writeExternal(java.io.ObjectOutput objectOutput) throws java.io.IOException {        Logger.getDefaultLogger().log(Logger.LOG_DEBUG,dumpString("***"));        Logger.getDefaultLogger().log(Logger.LOG_DEBUG,"Write object hash server buffer");        objectOutput.writeLong (serialVersion);        objectOutput.writeObject(dummyObject);        objectOutput.writeUTF(name==null?"":name);        Logger.getDefaultLogger().log(Logger.LOG_DEBUG,"Write object subbuffer");        objectOutput.writeObject(subBuffers);        Logger.getDefaultLogger().log(Logger.LOG_DEBUG,"Write object datas");        Logger.getDefaultLogger().log(Logger.LOG_DEBUG,datas.toString());        //Enumeration keys=datas.keys();        /*String str1;        while (keys.hasMoreElements())        {            str1=(String)keys.nextElement();            System.out.println ("dumping "+str1);            objectOutput.writeUTF (str1);            Object o = datas.get(str1);            System.out.println ("Type of : "+o.getClass().getName());            objectOutput.writeObject(o);                    }*/        objectOutput.writeObject(datas);    }        /** Getter for property time.     * @return Value of property time.     */        }