/* * DefaultMask.java * * Created on 10 mai 2002, 11:15 */package srcastra.astra.gui.sys.formVerification;// For Componentimport javax.swing.text.*;// For event Managing & Listenersimport javax.swing.event.SwingPropertyChangeSupport;import java.beans.PropertyChangeListener;// For locale languagesimport java.util.Locale;// Toolkitimport java.awt.Toolkit;/** * @author Sébastien */public class DefaultMask extends PlainDocument {////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// CONSTRUCTORS////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////    /**     * Creates new DefaultMask     */    public DefaultMask() {        this(0, 25, null, CASE_UNSENSITIVE);    }    /**     * Creates new DefaultMask     */    public DefaultMask(int minLenght, int maxLenght, int caseType) {        this(minLenght, maxLenght, null, caseType);    }    /**     * Creates new DefaultMask     */    public DefaultMask(int minLenght, int maxLenght, Locale locale, int caseType) {        this.maxLenght = maxLenght;        this.minLenght = minLenght;        this.locale = locale;        this.caseType = caseType;        this.correctInput = true;        this.m_supporter = new SwingPropertyChangeSupport(this);    }////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// METHODES APPARENTE AU BEANS////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////    private void insertStringWithCaseType(int offs, String str, AttributeSet a) throws BadLocationException {        if (caseType == FIRST_LETTRE_IN_UPPERCASE && offs == 0 && str != null && !str.equals("")) {            str = str.toUpperCase();        } else if (caseType == ALL_LETTRE_IN_UPPERCASE && str != null && !str.equals("")) {            str = str.toUpperCase();        } else if (caseType == ALL_LETTRE_IN_LOWERCASE && str != null && !str.equals("")) {            str = str.toLowerCase();        }        super.insertString(offs, str, a);    }    public void insertStringWithoutModification(int offs, String str, AttributeSet a) throws BadLocationException {        super.insertString(offs, str, a);    }    public void insertString(int offs, String str, AttributeSet a) throws BadLocationException {        String currentText = getText(0, getLength());        String beforeOffset = currentText.substring(0, offs);        String afterOffset = currentText.substring(offs, currentText.length());        boolean validate = false;        // regardons si il s'agit d'une action de validation        if (str.equals(DefaultMask.VALIDATE)) validate = true;        str = validate ? "" : str;        String proposedResult = beforeOffset + str + afterOffset;        boolean valid = true;        boolean fit = false;        /*-----------------------------------------------------------------------------*/        /* Traitement                                                                  */        /*-----------------------------------------------------------------------------*/        // le résulat proposé est inférieur au maximum imposé        if (proposedResult.length() <= maxLenght) {            valid = true;            fit = true;        }        // le résultat proposé est inférieur au minimum imposé        if (proposedResult.length() < minLenght) {            valid = false;            fit = true;        }        // le résultat proposé est supérieur au maximum imposé        if (!fit) {            getToolkit().beep();        }        /*-----------------------------------------------------------------------------*/        // le résultat proposé est valide => on insert        if (valid && fit) {            insertStringWithCaseType(offs, str, a);            confirmCorrectInput(true);        } else if (fit) {            insertStringWithCaseType(offs, str, a);            confirmCorrectInput(false);        }    }    protected void confirmCorrectInput(boolean correct) {        boolean oldValue = correctInput;        boolean newValue = correct;        this.correctInput = correct;        m_supporter.firePropertyChange(BEAN_CORRECTINPUT, oldValue, newValue);    }    public void remove(int offs, int len) throws BadLocationException {        super.remove(offs, len);        int longueurRestante = getLength();        /* Dans le cas on ne removerais qu'une partie de txt et que cette partie   * se trouverait au début de la chaîne et que le type requièrait une majuscule   * sur la première lettre */        if (offs == 0 && caseType == FIRST_LETTRE_IN_UPPERCASE) {            if (longueurRestante > 0) {                String premiereLettre = getText(0, 1);                premiereLettre = premiereLettre.toUpperCase();                super.remove(0, 1);                super.insertString(0, premiereLettre, null);                confirmCorrectInput(true);            }        }        /* si la longueur restante est inférieur au nombre minimal de charactère* pour l'encodage, on update correctInput en false */        if (longueurRestante < minLenght) confirmCorrectInput(false);    }    public void removeAll() throws BadLocationException {        super.remove(0, getLength());    }    protected Toolkit getToolkit() {        return Toolkit.getDefaultToolkit();    }    public String getGuiErrorCode() {        String erreur = "";        try {            erreur = java.util.ResourceBundle.getBundle("srcastra/astra/locale/ErreurFormVerification", locale).getString(String.valueOf(ERREUR_CODE));            int pos = erreur.indexOf("int*");            if (pos != -1) {                StringBuffer b = new StringBuffer(erreur);                b.replace(pos, pos + 4, String.valueOf(minLenght));                erreur = b.toString();            }            return erreur;        } catch (java.util.MissingResourceException mre) {            return "";        }    }////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// STATIC VARIABLES////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////    /**     * index pour mettre toute la chaîne du texfield en Majuscule     */    public static final int ALL_LETTRE_IN_UPPERCASE = 0;    /**     * index pour mettre la première lettre de la chaîne du texfield en Majuscule     */    public static final int FIRST_LETTRE_IN_UPPERCASE = 1;    /**     * index pour mettre toute la chaîne du texfield en minuscule     */    public static final int ALL_LETTRE_IN_LOWERCASE = 2;    /**     * index pour mettre ne rien faire au niveau de la case sur la chaine     */    public static final int CASE_UNSENSITIVE = 3;    /**     * Value for PropertyChangeListener     */    public static final String BEAN_CORRECTINPUT = "CorrectInput";    /**     * Value for PropertyChangeListener     */    public static final String BEAN_VALIDATE = "Validate";    /**     * value for erreur code     */    public static int ERREUR_CODE = FormVerification.ERREUR_VIDE;    /**     * special string for component validation     */    public static final String VALIDATE = "*#*VALIDATE*#*";////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// PROPERTIES////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////    protected int caseType;    protected int maxLenght;    protected int minLenght;    protected Locale locale;    protected boolean correctInput;    protected SwingPropertyChangeSupport m_supporter;////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// LISTENERS////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////    public void addPropertyChangeListener(PropertyChangeListener listener) {        m_supporter.addPropertyChangeListener(listener);    }    public void removePropertyChangeListener(PropertyChangeListener listener) {        m_supporter.removePropertyChangeListener(listener);    }////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// GET AND SETTER PROPERTIES FOR BEANS////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////    /**     * Getter for property maxLenght.     *     * @return Value of property maxLenght.     */    public int getMaxLenght() {        return maxLenght;    }    /**     * Setter for property maxLenght.     *     * @param maxLenght New value of property maxLenght.     */    public void setMaxLenght(int maxLenght) {        this.maxLenght = maxLenght;    }    /**     * Getter for property locale.     *     * @return Value of property locale.     */    public java.util.Locale getLocale() {        return locale;    }    /**     * Setter for property locale.     *     * @param locale New value of property locale.     */    public void setLocale(java.util.Locale locale) {        this.locale = locale;    }    /**     * Getter for property minLenght.     *     * @return Value of property minLenght.     */    public int getMinLenght() {        return minLenght;    }    /**     * Setter for property minLenght.     *     * @param minLenght New value of property minLenght.     */    public void setMinLenght(int minLenght) {        this.minLenght = minLenght;    }}